#!/usr/bin/env python

import pygtk
pygtk.require('2.0')

import mi_parser
import gtk
import gtk.glade
import vte
import subprocess
import threading
import re

class GdbInterface:
	#######################################################
	# work_function - thread runs dispaching commands
	# and notifying any waiting threads when commands finish
	def work_function(self):
		while(self.running):
			self.work_cond.acquire()
			while(len(self.cmd_queue) == 0):
				self.work_cond.wait()
			item = self.cmd_queue.pop()
			self.work_cond.release()

			print "executing item: " + item['cmd'] + ", " + item['type']

			# write the command to the GDB slave,
			# and return a result
			self.p.stdin.write(item['cmd'] + '\n')
			try:
				if(item['type'] == 'sync'):
					if(item['cmd'] == 'quit' or item['cmd'] == 'q'):
						item['result'] = True
					else:
						item['result'] = parse_result(item['cmd'])
					item['cond'].acquire()
					item['cond'].notify()
					item['cond'].release()
				else:
					self.read_until_prompt(item['cmd'])
					item['result'] = True
			except:
				item['result'] = False

			if(item['cmd'] == 'quit' or item['cmd'] == 'q'):
				return


	#######################################################
	# queue_work - place a work item (a hash containing
	# the GDB command and possibly a condition variable)
	# on the queue, wake up the GDB slave
	def queue_work(self, work):
		if(work['type'] == 'sync'):
			work['cond'] = threading.Condition()

		print "queueing " + work['type'] + ", " + work['cmd']

		work['result'] = None
		self.work_cond.acquire()
		self.cmd_queue.append(work)
		self.work_cond.notify()
		self.work_cond.release()

		# if work type is synchronous, wait for a result
		if(work['type'] == 'sync'):
			while(work['result'] == None):
				work['cond'].acquire()
				work['cond'].wait()
				work['cond'].release()
			return work['result']

		return True



	# read from GDB slave until prompt, but don't output any detail
	# into the buffer - quietly parse the result and return it
	def parse_result(self, *args):
		cmd = ''.join(v for v in args)
		l = self.p.stdout.readline()
		while self.prompt != l:
			try:
				res = mi_parser.process(l)
				print res
				if(res.record_type == 'result'):
					print "saw result!"
			except:
				print "Exception caught: line=" + l
			l = self.p.stdout.readline()

	def read_until_prompt(self, *args):
		l = ""
		cmd = ''.join(v for v in args)
		while self.prompt != l:
			l = self.p.stdout.readline()

			gtk.gdk.threads_enter()
		
			if(l == self.prompt):
				self.tbuf.insert(self.tbuf.get_end_iter(), l.rstrip('\n'))
			else:
				res = mi_parser.process(l)
				if(res.record_type == 'stream' and res.value != cmd):
					self.tbuf.insert(self.tbuf.get_end_iter(), res.value)
		
			self.tv.scroll_to_mark(self.tbuf.get_insert(), 0)

			gtk.gdk.threads_leave()
		
	def __init__(self, textview, textentry):
		self.cmd_limit = 100
		self.cmd_hist = []
		self.cmd_index = -1
		self.tv = textview
		self.tent = textentry
		self.left_control = self.right_control = False
		self.prompt = "(gdb) \n"
		self.p = subprocess.Popen("gdb -q -n -i mi", shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.STDOUT)
		self.tbuf = textview.get_buffer()
		self.tent.connect('key-press-event', self.buffer_key_pressed)
		self.tent.connect('key-release-event', self.buffer_key_released)
		self.read_until_prompt("")
		# state variables for the worker / slave thread
		self.running = True
		self.cmd_queue = []
		self.work_cond = threading.Condition()
		self.slave = threading.Thread(target = self.work_function)
		self.slave.start()

	##########################################################
	# buffer_key_pressed: handle events that don't generate
	# input (like arrow key presses and Ctrl+D) and insert command
	def buffer_key_pressed(self, widget, event):
		keyname = gtk.gdk.keyval_name(event.keyval)
		#print keyname
		if(keyname == "Up"):
			self.tent.set_text("")
			prev = self.prev_command()
			if(prev != ""):
				self.tent.set_text(prev)
				self.tent.set_position(len(prev))
			return True
		if(keyname == "Down" and self.cmd_index < len(self.cmd_hist)):
			self.tent.set_text("")
			nextcmd = self.next_command()
			if(nextcmd != ""):
				self.tent.set_text(nextcmd)
				self.tent.set_position(len(nextcmd))
			return True
		if(keyname == 'Control_R'):
			self.right_control = True
		if(keyname == 'Control_L'):
			self.left_control = True
		if(keyname == 'd' and (self.left_control or self.right_control)):
			self.run_command('quit')
			gtk.main_quit()
			return True
		if(keyname == 'Return'):
			t = self.tent.get_text()
			self.tent.set_text("")
			self.tbuf.insert(self.tbuf.get_end_iter(), t+"\n")
			self.tv.scroll_to_mark(self.tbuf.get_insert(), 0)
			self.run_command(t)
	
	##########################################################
	# buffer_key_released: handle key release events, specifically
	# useful for detecting when control and alt keys are released
	def buffer_key_released(self, widget, event):
		keyname = gtk.gdk.keyval_name(event.keyval)
		if(keyname == "Control_L"):
			self.left_control = False
		if(keyname == "Control_R"):
			self.right_control = False

	def reset(self):
	#reset debugging state
		if self.p != None:
			self.p.terminate()
		self.tbuf.insert_at_cursor("reset executable done\n")
	def debug(self, f):
		if self.debugging:
			reset()
		#start debugging
	
	##########################################################
	# run_command: save command to history, then run it (async)
	def run_command(self, cmd):
		# save the command to history and run it
		self.save_command(cmd)
		work = {'cmd': cmd, 'type': 'async'}
		if(cmd == "quit" or cmd == 'q' or cmd == 'QUIT'):
			work['type'] = 'sync'
			self.queue_work(work)
			gtk.main_quit()
		else:
			self.queue_work(work)

		# detect change to main file
		m = re.match('file\s+(.*)', cmd)
		if(m != None):
			self.change_file(m.group(0))

	##########################################################
	# change_file: re-populate the file->open_source menu
	#      and try to figure out where main is / open the file
	def change_file(self, fname):
		print "hey"
		#info sources
		#info functions main

	
	##########################################################
	# save_command: save a command to the command history list
	def save_command(self, cmd):
		if(len(self.cmd_hist) >= self.cmd_limit):
			self.cmd_hist.pop()
		self.cmd_hist.append(cmd)
		self.cmd_index = len(self.cmd_hist)

	##########################################################
	# prev_command: get the previous command in the history
	def prev_command(self):
		if(self.cmd_index == -1):
			return ""
		self.cmd_index = max(0, self.cmd_index-1)
		return self.cmd_hist[self.cmd_index]
	
	##########################################################
	# next_command: get the next command in the history
	def next_command(self):
		if(self.cmd_index == -1):
			return ""
		self.cmd_index += 1
		if(self.cmd_index >= len(self.cmd_hist)):
			return ""
		return self.cmd_hist[self.cmd_index]


class GDBG:
	def hello(self, widget, data=None):
		print "Hello World"
	def delete_event(self, widget, data=None):
		self.gi.run_command("quit")
		gtk.main_quit()
	def destroy(self, widget, data=None):
		self.gi.run_command("quit")
		gtk.main_quit()
	def clipboardevent(self, clipboard, event):
		val = clipboard.wait_for_text()
		if val != None:
			self.infolabel.set_text("Do you want to debug '" + val + "' ?")
			self.curfile = val
			self.infobar.show()
	def file_open(self, widget):
		response = self.chooser.run()
		if response == gtk.RESPONSE_OK:
			self.gi.run_command('file ' + self.chooser.get_filename())
		self.chooser.hide()
	def help_about(self, widget):
		about = self.builder.get_object('about_dialog')
		about.run()
		about.hide()
	def loadfile(self, widget):
		self.gi.reset()
		self.l.set_text("Debugging "+self.curfile)
		self.infobar.hide()
	def __init__(self):
		# set the gtk builder file
		self.builder = gtk.Builder()
		self.builder.add_from_file("gdbg.glade")
		self.builder.connect_signals(self)

		# initialize GDB interface
		self.gi = GdbInterface(self.builder.get_object('gdb_console'), self.builder.get_object('prompt'))

		# create a persistent File chooser outside of the glade file
		self.chooser = gtk.FileChooserDialog(title='Choose an executable to debug',
											 parent=self.builder.get_object('main_window'),
											 action=gtk.FILE_CHOOSER_ACTION_OPEN,
											 buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,
													  gtk.STOCK_OPEN,gtk.RESPONSE_OK))
		self.chooser.set_deletable(False)
		self.chooser.set_decorated(False)

		self.window = self.builder.get_object('main_window')
		self.window.show_all

	def main(self):
		gtk.main()
print __name__
if __name__ == "__main__":
	gtk.gdk.threads_init()
	app = GDBG()
	app.main()
	
