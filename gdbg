#!/usr/bin/env python

import pygtk
pygtk.require('2.0')

import gtk
import gtk.glade
import vte
import subprocess
import threading

class GdbInterface:
	def read_until_prompt(self):
		l = ""
		prompt = "(gdb) \n"
		while prompt != l:
			l = self.p.stdout.readline()

			gtk.gdk.threads_enter()
		
			# disable text insert signal handler 
			# so output from GDB doesn't trigger signal
			self.tbuf.handler_block(self.sig_id)

			if(l == prompt):
				self.tbuf.insert_at_cursor(l.rstrip('\n'))
			else:
				self.tbuf.insert_at_cursor(l)
		
			# enable text insert signal handler 
			self.tbuf.handler_unblock(self.sig_id)

			self.tv.scroll_to_mark(self.tbuf.get_insert(), 0)
			self.tbuf.apply_tag(self.tag_no_edit, 
								self.tbuf.get_start_iter(),
								self.tbuf.get_end_iter())

			gtk.gdk.threads_leave()
		
	def __init__(self, textview):
		self.cmd_limit = 100
		self.cmd_hist = []
		self.cmd_index = -1
		self.tv = textview
		self.p = subprocess.Popen("gdb -q -n -i mi", shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.STDOUT)
		self.tag_no_edit = gtk.TextTag('no_edit')
		self.tag_no_edit.set_property('editable', False)
		self.tbuf = textview.get_buffer()
		self.tbuf.tag_table.add(self.tag_no_edit)
		self.sig_id = self.tbuf.connect('insert-text', self.console_insert)
		self.read_until_prompt()
	def reset(self):
	#reset debugging state
		if self.p != None:
			self.p.terminate()
		self.tbuf.insert_at_cursor("reset executable done\n")
	def debug(self, f):
		if self.debugging:
			reset()
		#start debugging
	
	##########################################################
	# console_insert: handle inserted text in text buffer
	def console_insert(self, widget, length, new_text, position, data=None):
		#print new_text
		if(new_text.find("\n") >= 0):
			# let the user edit the command to their heart's content,
			# then figure out the command based on cursor and
			# prompt offset. First, set cursor to end.
			self.tbuf.place_cursor(self.tbuf.get_end_iter())
			start_iter = self.tbuf.get_iter_at_line_offset(
									self.tbuf.get_line_count() - 1,
									len("(gdb) "))
			command = self.tbuf.get_text(
							start_iter,
							self.tbuf.get_end_iter())
			#print "command = " + command
			
			# intercept a "quit" and turn it into a GUI exit also
			self.run_command(command + "\n")
			if(command == "quit" or command == "q"):
				gtk.main_quit()

	##########################################################
	# run_command: save command to history, then run it
	def run_command(self, cmd):
		# save the command to history and run it
		self.save_command(cmd)
		self.p.stdin.write(cmd)
		if(cmd != "quit\n"):
			threading.Thread(target = self.read_until_prompt).start()
	
	##########################################################
	# save_command: save a command to the command history list
	def save_command(self, cmd):
		if(len(self.cmd_hist) >= self.cmd_limit):
			self.cmd_hist.pop()
		self.cmd_hist.append(cmd)

	##########################################################
	# prev_command: get the previous command in the history
	def prev_command(self):
		if(self.cmd_index == -1):
			self.cmd_index = len(self.cmd_hist)
		self.cmd_index = max(0, self.cmd_index-1)
		return self.cmd_hist[self.cmd_index]
	
	##########################################################
	# next_command: get the next command in the history
	def prev_command(self):
		if(self.cmd_index == -1):
			self.cmd_index = len(self.cmd_hist) - 1
		cmd = self.cmd_hist[self.cmd_index]
		self.cmd_index += 1
		return cmd


class GDBG:
	def hello(self, widget, data=None):
		print "Hello World"
	def delete_event(self, widget, data=None):
		gtk.main_quit()
	def destroy(self, widget, data=None):
		gtk.main_quit()
	def clipboardevent(self, clipboard, event):
		val = clipboard.wait_for_text()
		if val != None:
			self.infolabel.set_text("Do you want to debug '" + val + "' ?")
			self.curfile = val
			self.infobar.show()
	def loadfile(self, widget):
		self.gi.reset()
		self.l.set_text("Debugging "+self.curfile)
		self.infobar.hide()
	def __init__(self):
		# set the gtk builder file
		self.builder = gtk.Builder()
		self.builder.add_from_file("gdbg.xml")
		self.builder.connect_signals(self)

		# initialize GDB interface
		self.gi = GdbInterface(self.builder.get_object('gdb_console'))

		self.window = self.builder.get_object('main_window')
		self.window.show_all

	def main(self):
		gtk.main()
print __name__
if __name__ == "__main__":
	gtk.gdk.threads_init()
	app = GDBG()
	app.main()
	
