#!/usr/bin/env python

import pygtk
pygtk.require('2.0')

import mi_parser
import gtk
import gtk.glade
import vte
import subprocess
import threading

class GdbInterface:
	def read_until_prompt(self, *args):
		l = ""
		cmd = ''.join(v for v in args)
		prompt = "(gdb) \n"
		while prompt != l:
			l = self.p.stdout.readline()

			gtk.gdk.threads_enter()
		
			# disable text insert signal handler 
			# so output from GDB doesn't trigger signal
			self.tbuf.handler_block(self.sig_id)

			if(l == prompt):
				self.tbuf.insert_at_cursor(l.rstrip('\n'))
			else:
				res = mi_parser.process(l)
				if(res.record_type == 'stream' and res.value != cmd):
					self.tbuf.insert_at_cursor(res.value)
		
			# enable text insert signal handler 
			self.tbuf.handler_unblock(self.sig_id)

			self.tv.scroll_to_mark(self.tbuf.get_insert(), 0)
			self.tbuf.apply_tag(self.tag_no_edit, 
								self.tbuf.get_start_iter(),
								self.tbuf.get_end_iter())

			gtk.gdk.threads_leave()
		
	def __init__(self, textview):
		self.cmd_limit = 100
		self.cmd_hist = []
		self.cmd_index = -1
		self.tv = textview
		self.left_control = self.right_control = False
		self.p = subprocess.Popen("gdb -q -n -i mi", shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.STDOUT)
		self.tag_no_edit = gtk.TextTag('no_edit')
		self.tag_no_edit.set_property('editable', False)
		self.tbuf = textview.get_buffer()
		self.tbuf.tag_table.add(self.tag_no_edit)
		self.sig_id = self.tbuf.connect('insert-text', self.console_insert)
		self.tv.connect('key-press-event', self.buffer_key_pressed)
		self.tv.connect('key-release-event', self.buffer_key_released)
		self.read_until_prompt("")

	##########################################################
	# clear_cur_command: clear out the current line and make
	# way for some new text (a previous or next command)
	def clear_cur_command(self):
		start_iter = self.tbuf.get_iter_at_line_offset(
								self.tbuf.get_line_count() - 1,
								len("(gdb) "))
		self.tbuf.delete_interactive(start_iter,
									 self.tbuf.get_end_iter(),
									 True)

	
	##########################################################
	# buffer_key_pressed: handle events that don't generate
	# input (like arrow key presses and Ctrl+D) and insert command
	def buffer_key_pressed(self, widget, event):
		keyname = gtk.gdk.keyval_name(event.keyval)
		#print keyname
		if(keyname == "Up"):
			self.clear_cur_command()
			prev = self.prev_command()
			if(prev != ""):
				self.tbuf.insert_at_cursor(prev)
			return True
		if(keyname == "Down" and self.cmd_index < len(self.cmd_hist)):
			self.clear_cur_command()
			nextcmd = self.next_command()
			if(nextcmd != ""):
				self.tbuf.insert_at_cursor(nextcmd)
			return True
		if(keyname == 'Control_R'):
			self.right_control = True
		if(keyname == 'Control_L'):
			self.left_control = True
		if(keyname == 'd' and (self.left_control or self.right_control)):
			gtk.main_quit()
			return True
	
	##########################################################
	# buffer_key_released: handle key release events, specifically
	# useful for detecting when control and alt keys are released
	def buffer_key_released(self, widget, event):
		keyname = gtk.gdk.keyval_name(event.keyval)
		if(keyname == "Control_L"):
			self.left_control = False
		if(keyname == "Control_R"):
			self.right_control = False

	def reset(self):
	#reset debugging state
		if self.p != None:
			self.p.terminate()
		self.tbuf.insert_at_cursor("reset executable done\n")
	def debug(self, f):
		if self.debugging:
			reset()
		#start debugging
	
	##########################################################
	# console_insert: handle inserted text in text buffer
	def console_insert(self, widget, length, new_text, position, data=None):
		#print new_text
		if(new_text.find("\n") >= 0):
			# let the user edit the command to their heart's content,
			# then figure out the command based on cursor and
			# prompt offset. First, set cursor to end.
			self.tbuf.place_cursor(self.tbuf.get_end_iter())
			start_iter = self.tbuf.get_iter_at_line_offset(
									self.tbuf.get_line_count() - 1,
									len("(gdb) "))
			command = self.tbuf.get_text(
							start_iter,
							self.tbuf.get_end_iter())
			#print "command = " + command
			
			# intercept a "quit" and turn it into a GUI exit also
			self.run_command(command)
			if(command == "quit" or command == "q"):
				gtk.main_quit()

	##########################################################
	# run_command: save command to history, then run it
	def run_command(self, cmd):
		# save the command to history and run it
		self.save_command(cmd)
		self.p.stdin.write(cmd + '\n')
		if(cmd != "quit"):
			threading.Thread(target = self.read_until_prompt,
							 args = (cmd+'\n')).start()
	
	##########################################################
	# save_command: save a command to the command history list
	def save_command(self, cmd):
		if(len(self.cmd_hist) >= self.cmd_limit):
			self.cmd_hist.pop()
		self.cmd_hist.append(cmd)
		self.cmd_index = len(self.cmd_hist)

	##########################################################
	# prev_command: get the previous command in the history
	def prev_command(self):
		if(self.cmd_index == -1):
			return ""
		self.cmd_index = max(0, self.cmd_index-1)
		return self.cmd_hist[self.cmd_index]
	
	##########################################################
	# next_command: get the next command in the history
	def next_command(self):
		if(self.cmd_index == -1):
			return ""
		self.cmd_index += 1
		if(self.cmd_index >= len(self.cmd_hist)):
			return ""
		return self.cmd_hist[self.cmd_index]


class GDBG:
	def hello(self, widget, data=None):
		print "Hello World"
	def delete_event(self, widget, data=None):
		gtk.main_quit()
	def destroy(self, widget, data=None):
		gtk.main_quit()
	def clipboardevent(self, clipboard, event):
		val = clipboard.wait_for_text()
		if val != None:
			self.infolabel.set_text("Do you want to debug '" + val + "' ?")
			self.curfile = val
			self.infobar.show()
	def loadfile(self, widget):
		self.gi.reset()
		self.l.set_text("Debugging "+self.curfile)
		self.infobar.hide()
	def __init__(self):
		# set the gtk builder file
		self.builder = gtk.Builder()
		self.builder.add_from_file("gdbg.xml")
		self.builder.connect_signals(self)

		# initialize GDB interface
		self.gi = GdbInterface(self.builder.get_object('gdb_console'))

		self.window = self.builder.get_object('main_window')
		self.window.show_all

	def main(self):
		gtk.main()
print __name__
if __name__ == "__main__":
	gtk.gdk.threads_init()
	app = GDBG()
	app.main()
	
